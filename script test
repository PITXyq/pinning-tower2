--[[
    Script Modified:
    - Replaced TARGET_POSITION_R with new coordinates: Vector3.new(159.594803, 153.999939, 247.499298)
    - Changed TARGET_PART_NAME_E from "Gudock" to "button"
    - Changed TARGET_POSITION_G (Platform Position) to be 6 studs lower than TARGET_POSITION_R
    - Changed TARGET_POSITION_H (H Detection / Q Trigger Zone) to new coordinates: Vector3.new(196.113449, 153.999924, 254.413132)
    - Changed E key UI text back to "E: Troll button"
    - Moved Status Labels UI higher (reduced topPadding)
    - Changed DETECT_POSITION_G (G Detection / E Trigger Zone) to new coordinates: Vector3.new(154.080551, 156.734482, 214.55484)
]]

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
-- Wait longer for character if needed, especially on slower connections or complex spawns
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
-- Add extra waits for humanoid and root part just in case
local Humanoid = Character:WaitForChild("Humanoid", 10)
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 10)

-- Configuration for Q Key (Teleporting "other" parts)
local TARGET_PART_NAME_Q = "사라지는 파트" -- Name of parts to teleport with Q
local TELEPORT_DURATION_Q = 0.1         -- How long parts stay teleported (seconds)
local TRIGGER_KEY_Q = Enum.KeyCode.Q    -- Key to trigger this action

-- Configuration for E Key (Teleporting "button" parts)
local TARGET_PART_NAME_E = "button"     -- Name of parts to teleport with E
local TELEPORT_DURATION_E = 0.1         -- How long parts stay teleported (seconds)
local TRIGGER_KEY_E = Enum.KeyCode.E    -- Key to trigger this action

-- Configuration for R Key (Teleport Player)
local TRIGGER_KEY_R = Enum.KeyCode.R    -- Key to trigger this action
local TARGET_POSITION_R = Vector3.new(159.594803, 153.999939, 247.499298) -- Target coordinates

-- Configuration for F Key (Anti-Fall)
local TRIGGER_KEY_F = Enum.KeyCode.F    -- Key to toggle Anti-Fall
local ANTI_FALL_Y_THRESHOLD = TARGET_POSITION_R.Y - 50 -- Y level below target to trigger teleport
local ANTI_FALL_COOLDOWN = 1            -- Seconds before Anti-Fall can trigger again

-- Configuration for G Key (Detect Players near G zone -> Trigger E action)
local TRIGGER_KEY_G = Enum.KeyCode.G    -- Key to toggle this detection
-- <<< MODIFIED LINE >>> -- G detection zone center updated
local DETECT_POSITION_G = Vector3.new(154.080551, 156.734482, 214.55484) -- Center of detection zone G
local DETECTION_RADIUS_G = 5            -- Radius (studs) for detection zone G
local PLAYER_DETECT_COOLDOWN_G = 0.5    -- Seconds before G detection can trigger again

-- Configuration for P Key (Platform) & TARGET_POSITION_G
local TRIGGER_KEY_PLATFORM = Enum.KeyCode.P -- Key to toggle the platform
local TARGET_POSITION_G = TARGET_POSITION_R - Vector3.new(0, 6, 0) -- Lowered platform by 6 studs
local PLATFORM_SIZE = Vector3.new(200, 5, 200) -- Size of the platform part
local PLATFORM_COLOR = Color3.fromRGB(100, 200, 255) -- Color of the platform
local PLATFORM_TRANSPARENCY_VISIBLE = 0.5 -- Transparency when visible
local PLATFORM_TRANSPARENCY_HIDDEN = 1    -- Transparency when hidden
local PLATFORM_ANCHORED = true            -- Should the platform be anchored?
local PLATFORM_CAN_COLLIDE = true         -- Can players collide with the platform when visible?

-- Configuration for H Key (Detect Players near H zone -> Trigger Q action)
local TRIGGER_KEY_H = Enum.KeyCode.H    -- Key to toggle this detection
local TARGET_POSITION_H = Vector3.new(196.113449, 153.999924, 254.413132) -- Center of detection zone H
local DETECTION_RADIUS_H = 15           -- Radius (studs) for detection zone H
local PLAYER_DETECT_COOLDOWN_H = PLAYER_DETECT_COOLDOWN_G -- Cooldown (uses G's cooldown)

-- Configuration for X Key (Fly)
local TRIGGER_KEY_FLY = Enum.KeyCode.X  -- Key to toggle Fly mode
local QEfly = true                      -- Allow Q/E for vertical flight on PC?
local iyflyspeed = 1                    -- Base fly speed multiplier
local vehicleflyspeed = 1               -- Base fly speed multiplier (unused in current setup)

-- Internal State Variables
local FLYING = false                    -- Is the player currently flying?
local flyKeyDownConnection = nil        -- Connection for key down event (fly)
local flyKeyUpConnection = nil          -- Connection for key up event (fly)
local flyRenderStepConnection = nil     -- Connection for RenderStepped (mobile fly)
local flyCharacterAddedConnection = nil -- Connection for CharacterAdded (mobile fly persistence)
local flyBG = nil                       -- BodyGyro instance for flying
local flyBV = nil                       -- BodyVelocity instance for flying
local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} -- PC Fly controls state
local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} -- Previous PC Fly controls state
local SPEED = 0                         -- Current fly speed calculation variable

local isPlatformVisible = false         -- Is the platform currently visible/active?
local platformPartRef = nil             -- Reference to the platform Part instance

local isPartTeleporting = false         -- Is a part teleport action currently in progress?
local originalStateData = {}            -- Stores original properties of teleported parts

local isAntiFallEnabled = false         -- Is the Anti-Fall feature enabled?
local lastAntiFallTime = 0              -- Timestamp of the last Anti-Fall trigger

local isGFuncEnabled = false            -- Is the G detection feature enabled?
local lastPlayerDetectTime_G = 0        -- Timestamp of the last G detection trigger

local isHFuncEnabled = false            -- Is the H detection feature enabled?
local lastPlayerDetectTime_H = 0        -- Timestamp of the last H detection trigger

-- UI Element References
local antiFallButtonRef = nil
local gFuncButtonRef = nil
local hFuncButtonRef = nil
local flyButtonRef = nil
local platformButtonRef = nil
local uiToggleButtonRef = nil
local antiFallStatusLabelRef = nil
local gFuncStatusLabelRef = nil
local hFuncStatusLabelRef = nil
local flyStatusLabelRef = nil
local platformStatusLabelRef = nil
local keybindsLabelRef = nil
local gVisualizerPartRef = nil          -- Reference to the G detection visualizer Part
local hVisualizerPartRef = nil          -- Reference to the H detection visualizer Part

--[[
    Recursively sets visibility properties for an instance and its descendants.
    Used to hide parts during teleportation (specifically for E key).
    Stores original properties in stateStore for potential restoration.
    @param instance: The root Instance to modify.
    @param visible: Boolean, true to restore/keep visible, false to hide.
    @param stateStore: Table to store the original properties of modified instances.
]]
local function setVisibilityRecursive(instance, visible, stateStore)
	if not instance then return end
	local originalProps = {}
	-- Handle BaseParts (Transparency)
	if instance:IsA("BasePart") then
		originalProps.Transparency = instance.Transparency
		instance.Transparency = visible and originalProps.Transparency or 1
	end
	-- Handle Decals/Textures (Transparency)
	if instance:IsA("Decal") or instance:IsA("Texture") then
		originalProps.Transparency = instance.Transparency
		instance.Transparency = visible and originalProps.Transparency or 1
	end
	-- Handle other visual elements (Enabled property)
	if instance:IsA("SurfaceGui") or instance:IsA("ParticleEmitter") or instance:IsA("PointLight") or instance:IsA("SpotLight") or instance:IsA("SurfaceLight") or instance:IsA("Highlight") then
		originalProps.Enabled = instance.Enabled
		instance.Enabled = visible -- Directly use boolean for Enabled
	end
	-- Store original properties if hiding and properties were changed
	if not visible and next(originalProps) then
		stateStore[instance] = originalProps
	end
	-- Recurse through children
	for _, child in ipairs(instance:GetChildren()) do
		setVisibilityRecursive(child, visible, stateStore)
	end
end

--[[
    Handles the teleportation of parts based on name.
    Finds parts, teleports them to the player, waits, and returns them.
    @param targetPartName: The Name property of the parts to find and teleport.
    @param teleportDuration: How long (seconds) the parts stay teleported.
    @param triggerSource: String indicating what triggered the function (e.g., "Q Key", "G Detection").
]]
local function handlePartTeleport(targetPartName, teleportDuration, triggerSource)
	-- Prevent overlapping teleports
	if isPartTeleporting then print("Part teleport already in progress (requested by " .. triggerSource .. ")."); return end
	local player = LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local currentHumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not currentHumanoidRootPart then warn("HumanoidRootPart not found (" .. triggerSource .. ")."); return end

	print(triggerSource .. " action triggered, searching for parts named:", targetPartName)
	isPartTeleporting = true
	originalStateData = {} -- Clear previous state data
	local partsToTeleport = {}
	local foundParts = false

	-- Find all parts matching the target name in the Workspace
	for _, descendant in ipairs(Workspace:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant.Name == targetPartName then
			table.insert(partsToTeleport, descendant)
			-- Store original state (main part and initialize children table)
			originalStateData[descendant] = {
				main = { CFrame = descendant.CFrame, Anchored = descendant.Anchored, CanCollide = descendant.CanCollide, Transparency = descendant.Transparency }, -- Store Transparency too
				children = {}
			}
			foundParts = true
		end
	end

	if foundParts then
		print("Found", #partsToTeleport, "parts via " .. triggerSource .. ". Teleporting them...")
		local targetCFrame = currentHumanoidRootPart.CFrame -- Target is player's current position

		-- Teleport phase
		for _, part in ipairs(partsToTeleport) do
			if part and part.Parent and originalStateData[part] then
				part.Anchored = true      -- Anchor temporarily
				part.CanCollide = false   -- Disable collision temporarily
				-- Only hide the E button parts when triggered manually by E key, not by G detection
				-- Only hide the Q button parts when triggered manually by Q key, not by H detection
				if (targetPartName == TARGET_PART_NAME_E and triggerSource == "E Key") or (targetPartName == TARGET_PART_NAME_Q and triggerSource == "Q Key") then
					setVisibilityRecursive(part, false, originalStateData[part].children)
				end
				part.CFrame = targetCFrame -- Move to player
			end
		end

		task.wait(teleportDuration) -- Wait for the specified duration
		print("Returning parts triggered by " .. triggerSource .. "...")

		-- Return phase
		for _, part in ipairs(partsToTeleport) do
			if part and part.Parent and originalStateData[part] then
				local originalMainData = originalStateData[part].main
				local originalChildrenData = originalStateData[part].children

				-- Restore main properties
				part.CFrame = originalMainData.CFrame
				part.Anchored = originalMainData.Anchored
				part.CanCollide = originalMainData.CanCollide
				part.Transparency = originalMainData.Transparency -- Restore original transparency

                -- Only restore visibility if it was hidden earlier (manual key trigger)
				if (targetPartName == TARGET_PART_NAME_E and triggerSource == "E Key") or (targetPartName == TARGET_PART_NAME_Q and triggerSource == "Q Key") then
                    -- Restore children visibility/properties first
					for instance, props in pairs(originalChildrenData) do
						if instance and instance.Parent then
							for propName, originalValue in pairs(props) do
								-- Use pcall for safety when setting properties
								local success, err = pcall(function() instance[propName] = originalValue end)
								if not success then warn("Failed to restore property", propName, "on", instance:GetFullName(), ":", err) end
							end
						end
					end
                    -- Restore main part's transparency again (redundant but safe) if it was specifically stored in children data
                    if originalChildrenData[part] and originalChildrenData[part].Transparency ~= nil then
                         pcall(function() part.Transparency = originalChildrenData[part].Transparency end)
                    else
						-- Ensure it's visible if no specific transparency was stored for the main part itself in the children table
						pcall(function() part.Transparency = originalMainData.Transparency end)
					end
				end
			end
		end
		print("Parts return complete for " .. triggerSource .. ".")
	else
		print("No parts found with the name '" .. targetPartName .. "' for trigger " .. triggerSource)
	end

	isPartTeleporting = false -- Allow new teleports
	originalStateData = {}    -- Clear state data
end

--[[
    Teleports the local player to the specified coordinates.
    @param targetPosition: Vector3 coordinates to teleport to.
    @param triggerSource: String indicating what triggered the function (e.g., "R Key", "Anti-Fall").
]]
local function teleportPlayerToCoords(targetPosition, triggerSource)
	local player = LocalPlayer
	local character = player.Character
	if not character then warn("Player character not found (" .. triggerSource .. ")."); return end
	local currentHumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not currentHumanoidRootPart then warn("HumanoidRootPart not found (" .. triggerSource .. ")."); return end

	print(triggerSource .. " action triggered, teleporting player to:", targetPosition)
	currentHumanoidRootPart.CFrame = CFrame.new(targetPosition) -- Set CFrame directly
end

-- Functions to update the status labels in the UI
local function updateAntiFallStatusLabel()
	if antiFallStatusLabelRef then
		if isAntiFallEnabled then
			antiFallStatusLabelRef.Text = "Anti-Fall: Enabled"
			antiFallStatusLabelRef.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
		else
			antiFallStatusLabelRef.Text = "Anti-Fall: Disabled"
			antiFallStatusLabelRef.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
		end
	end
end
local function updateGFuncStatusLabel()
	if gFuncStatusLabelRef then
		if isGFuncEnabled then
			gFuncStatusLabelRef.Text = "Troll Detect: Enabled"
			gFuncStatusLabelRef.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
		else
			gFuncStatusLabelRef.Text = "Troll Detect: Disabled"
			gFuncStatusLabelRef.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
		end
	end
end
local function updateHFuncStatusLabel()
	if hFuncStatusLabelRef then
		if isHFuncEnabled then
			hFuncStatusLabelRef.Text = "Other Detect: Enabled"
			hFuncStatusLabelRef.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
		else
			hFuncStatusLabelRef.Text = "Other Detect: Disabled"
			hFuncStatusLabelRef.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
		end
	end
end
local function updateFlyStatusLabel()
	if flyStatusLabelRef then
		if FLYING then
			flyStatusLabelRef.Text = "Fly: Enabled"
			flyStatusLabelRef.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
		else
			flyStatusLabelRef.Text = "Fly: Disabled"
			flyStatusLabelRef.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
		end
	end
end
local function updatePlatformStatusLabel()
	if platformStatusLabelRef then
		if isPlatformVisible then
			platformStatusLabelRef.Text = "Platform: Enabled"
			platformStatusLabelRef.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green
		else
			platformStatusLabelRef.Text = "Platform: Disabled"
			platformStatusLabelRef.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red
		end
	end
end

-- Functions to update the mobile buttons' appearance (Text and Color)
local function updateAntiFallMobileButton()
	if antiFallButtonRef then
		if isAntiFallEnabled then
			antiFallButtonRef.Text = "F: AntiFall ON"
			antiFallButtonRef.BackgroundColor3 = Color3.fromRGB(50, 180, 50) -- Greenish
			antiFallButtonRef.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			antiFallButtonRef.Text = "F: AntiFall OFF"
			antiFallButtonRef.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Reddish
			antiFallButtonRef.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end
end
local function updateGFuncMobileButton()
	if gFuncButtonRef then
		if isGFuncEnabled then
			gFuncButtonRef.Text = "G: Troll Detect ON"
			gFuncButtonRef.BackgroundColor3 = Color3.fromRGB(50, 180, 50) -- Greenish
			gFuncButtonRef.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			gFuncButtonRef.Text = "G: Troll Detect OFF"
			gFuncButtonRef.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Reddish
			gFuncButtonRef.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end
end
local function updateHFuncMobileButton()
	if hFuncButtonRef then
		if isHFuncEnabled then
			hFuncButtonRef.Text = "H: Other Detect ON"
			hFuncButtonRef.BackgroundColor3 = Color3.fromRGB(50, 180, 50) -- Greenish
			hFuncButtonRef.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			hFuncButtonRef.Text = "H: Other Detect OFF"
			hFuncButtonRef.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Reddish
			hFuncButtonRef.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end
end
local function updateFlyMobileButton()
	if flyButtonRef then
		if FLYING then
			flyButtonRef.Text = "X: Fly ON"
			flyButtonRef.BackgroundColor3 = Color3.fromRGB(50, 180, 50) -- Greenish
			flyButtonRef.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			flyButtonRef.Text = "X: Fly OFF"
			flyButtonRef.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Reddish
			flyButtonRef.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end
end
local function updatePlatformMobileButton()
	if platformButtonRef then
		if isPlatformVisible then
			platformButtonRef.Text = "P: Platform ON"
			platformButtonRef.BackgroundColor3 = Color3.fromRGB(50, 180, 50) -- Greenish
			platformButtonRef.TextColor3 = Color3.fromRGB(255, 255, 255)
		else
			platformButtonRef.Text = "P: Platform OFF"
			platformButtonRef.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Reddish
			platformButtonRef.TextColor3 = Color3.fromRGB(220, 220, 220)
		end
	end
end

-- Toggle Functions (called by key presses or button clicks)
local function toggleAntiFall()
	isAntiFallEnabled = not isAntiFallEnabled
	print("Anti-Fall Toggled:", isAntiFallEnabled and "ON" or "OFF")
	updateAntiFallStatusLabel()
	updateAntiFallMobileButton()
end
local function toggleGFunc()
	isGFuncEnabled = not isGFuncEnabled
	print("Player Detection (G -> Troll) Toggled:", isGFuncEnabled and "ON" or "OFF")
	updateGFuncStatusLabel()
	updateGFuncMobileButton()
	-- Toggle visualizer visibility
	if gVisualizerPartRef then gVisualizerPartRef.Visible = isGFuncEnabled end
    print("DEBUG: isGFuncEnabled set to:", isGFuncEnabled) -- Debug print
end
local function toggleHFunc()
	isHFuncEnabled = not isHFuncEnabled
	print("Player Detection (H -> Other) Toggled:", isHFuncEnabled and "ON" or "OFF")
	updateHFuncStatusLabel()
	updateHFuncMobileButton()
	-- Toggle visualizer visibility
	if hVisualizerPartRef then hVisualizerPartRef.Visible = isHFuncEnabled end
end

-- Fly Functions
--[[ Stops PC fly mode ]]
local function NOFLY()
	FLYING = false
	-- Disconnect input listeners if they exist
	if flyKeyDownConnection then flyKeyDownConnection:Disconnect(); flyKeyDownConnection = nil end
	if flyKeyUpConnection then flyKeyUpConnection:Disconnect(); flyKeyUpConnection = nil end
	-- Remove BodyMovers if they exist
	local currentRootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	if currentRootPart then
		if flyBG and flyBG.Parent == currentRootPart then flyBG:Destroy() end
		if flyBV and flyBV.Parent == currentRootPart then flyBV:Destroy() end
	end
	flyBG = nil
	flyBV = nil
	-- Reset PlatformStand and CameraType
	if Humanoid then Humanoid.PlatformStand = false end
	pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
	print("IY Fly Disabled (PC)")
end

--[[ Starts PC fly mode ]]
local function sFLY(vfly) -- vfly parameter seems unused
	if FLYING then NOFLY() end -- Stop if already flying
	wait() -- Short delay before starting
	-- Ensure character components are available
	if not Character or not Humanoid or not HumanoidRootPart then print("Cannot start fly: Character components missing."); return end

	FLYING = true
	local T = HumanoidRootPart -- Shortcut for HumanoidRootPart

	-- Clean up any existing fly movers (just in case)
	if flyBG and flyBG.Parent then flyBG:Destroy() end
	if flyBV and flyBV.Parent then flyBV:Destroy() end

	-- Create BodyGyro for orientation control
	flyBG = Instance.new('BodyGyro')
	flyBG.P = 9e4 -- Proportional gain (controls stiffness)
	flyBG.Parent = T
	flyBG.maxTorque = Vector3.new(9e9, 9e9, 9e9) -- High max torque
	flyBG.cframe = T.CFrame -- Initial CFrame

	-- Create BodyVelocity for movement control
	flyBV = Instance.new('BodyVelocity')
	flyBV.Parent = T
	flyBV.velocity = Vector3.new(0, 0, 0) -- Initial velocity
	flyBV.maxForce = Vector3.new(9e9, 9e9, 9e9) -- High max force

	-- Reset control states
	CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	SPEED = 0

	-- Start the fly update loop in a separate thread
	task.spawn(function()
		local flyLoopActive = true
		-- Connect to Heartbeat for physics-related updates
		local connection = RunService.Heartbeat:Connect(function()
			-- Stop loop if flying is disabled or movers are gone
			if not FLYING or not flyBV or not flyBV.Parent or not flyBG or not flyBG.Parent then
				flyLoopActive = false
				return
			end
			-- Keep player floating
			if Humanoid then Humanoid.PlatformStand = true end

			-- Determine if moving
			if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
				SPEED = 50 -- Base speed when moving
			elseif SPEED ~= 0 then -- If stopped moving, reset speed
				SPEED = 0
			end

			local currentSpeed = iyflyspeed -- Use base speed multiplier

			-- Calculate movement direction based on camera and controls
			if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
				local camFrame = workspace.CurrentCamera.CFrame
				local lookVector = camFrame.lookVector -- Forward direction
				local rightVector = camFrame.rightVector -- Right direction

				-- Combine horizontal and vertical movement vectors
				local moveDir = (lookVector * (CONTROL.F + CONTROL.B)) + (rightVector * (CONTROL.L + CONTROL.R))
				local verticalDir = Vector3.new(0, (CONTROL.Q + CONTROL.E), 0) -- Q/E for up/down

				flyBV.velocity = (moveDir + verticalDir) * SPEED * currentSpeed -- Apply speed and multiplier
				lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R} -- Store last direction (seems slightly flawed logic here)

			elseif SPEED == 0 then -- If speed is 0 (stopped moving), explicitly set velocity to zero
				flyBV.velocity = Vector3.new(0,0,0)
			else -- Default case (shouldn't be reached often with current logic)
				flyBV.velocity = Vector3.new(0, 0, 0)
			end
			-- Constantly update BodyGyro CFrame to match camera orientation
			flyBG.cframe = workspace.CurrentCamera.CFrame
		end)

		-- Keep the loop running until flyLoopActive is false
		while flyLoopActive do wait() end
		connection:Disconnect() -- Disconnect the Heartbeat listener
		print("Fly Heartbeat loop stopped.")
	end)

	-- Connect keyboard input listeners for PC fly
	if flyKeyDownConnection then flyKeyDownConnection:Disconnect() end
	flyKeyDownConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or not FLYING then return end -- Ignore if typing in chat or not flying
		local KEY = input.KeyCode.Name:lower()
		if KEY == 'w' then CONTROL.F = 1
		elseif KEY == 's' then CONTROL.B = -1
		elseif KEY == 'a' then CONTROL.L = -1
		elseif KEY == 'd' then CONTROL.R = 1
		elseif QEfly and KEY == 'e' then CONTROL.Q = 1 -- Up
		elseif QEfly and KEY == 'q' then CONTROL.E = -1 -- Down
		end
	end)

	if flyKeyUpConnection then flyKeyUpConnection:Disconnect() end
	flyKeyUpConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if not FLYING then return end -- Only process if flying
		local KEY = input.KeyCode.Name:lower()
		if KEY == 'w' then CONTROL.F = 0
		elseif KEY == 's' then CONTROL.B = 0
		elseif KEY == 'a' then CONTROL.L = 0
		elseif KEY == 'd' then CONTROL.R = 0
		elseif KEY == 'e' then CONTROL.Q = 0
		elseif KEY == 'q' then CONTROL.E = 0
		end
	end)

	print("IY Fly Enabled (Keyboard)")
end

--[[ Starts Mobile fly mode ]]
local function mobilefly()
	if FLYING then unmobilefly() end -- Use unmobilefly to stop previous mobile fly
	wait()
	if not Character or not Humanoid or not HumanoidRootPart then print("Cannot start mobile fly: Character components missing."); return end

	FLYING = true
	local T = HumanoidRootPart
	local camera = Workspace.CurrentCamera
	local v3zero = Vector3.new(0, 0, 0)
	local v3inf = Vector3.new(9e9, 9e9, 9e9) -- Representation of infinity for MaxForce/Torque

	-- Clean up existing movers
	if flyBG and flyBG.Parent then flyBG:Destroy() end
	if flyBV and flyBV.Parent then flyBV:Destroy() end

	-- Create BodyVelocity
	flyBV = Instance.new("BodyVelocity")
	flyBV.Name = "IYMobileFlyBV"
	flyBV.Parent = T
	flyBV.MaxForce = v3inf
	flyBV.Velocity = v3zero

	-- Create BodyGyro
	flyBG = Instance.new("BodyGyro")
	flyBG.Name = "IYMobileFlyBG"
	flyBG.Parent = T
	flyBG.MaxTorque = v3inf
	flyBG.P = 10000 -- Proportional gain
	flyBG.D = 500   -- Derivative gain (damping)

	-- Disconnect previous RenderStepped listener if exists
	if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end

	-- Connect to RenderStepped for smooth camera-relative movement updates
	flyRenderStepConnection = RunService.RenderStepped:Connect(function()
		-- Stop if not flying or essential components are missing
		if not FLYING or not Character or not Humanoid or not T or not T.Parent or not flyBV or not flyBV.Parent or not flyBG or not flyBG.Parent then
			if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end
			unmobilefly() -- Clean up
			return
		end

		Humanoid.PlatformStand = true -- Keep floating
		flyBG.CFrame = camera.CFrame -- Match camera orientation

		local direction = Humanoid.MoveDirection -- Get input from mobile joystick
		local currentSpeed = iyflyspeed * 50 -- Calculate speed

		-- Apply velocity based on joystick direction relative to camera
		if direction.Magnitude > 0.01 then -- Check if joystick is moved
			local lookVector = camera.CFrame.LookVector
			local rightVector = camera.CFrame.RightVector
			-- Combine forward/backward (Z) and left/right (X) movement based on joystick input
			local moveDir = (lookVector * -direction.Z) + (rightVector * direction.X)
			flyBV.Velocity = moveDir.Unit * currentSpeed -- Apply calculated velocity
		else
			flyBV.Velocity = v3zero -- Stop if joystick is centered
		end
	end)

	-- Handle character respawn for mobile fly persistence
	if flyCharacterAddedConnection then flyCharacterAddedConnection:Disconnect(); flyCharacterAddedConnection = nil end
	flyCharacterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
		Character = newChar
		Humanoid = newChar:WaitForChild("Humanoid", 5)
		HumanoidRootPart = newChar:WaitForChild("HumanoidRootPart", 5)
		T = HumanoidRootPart
		if FLYING then -- If was flying before respawn
			task.wait(0.5) -- Wait briefly for character to fully load
			if T and T.Parent then -- Re-create movers on the new character
				if flyBG and flyBG.Parent then flyBG:Destroy() end
				if flyBV and flyBV.Parent then flyBV:Destroy() end
				flyBV = Instance.new("BodyVelocity")
				flyBV.Name = "IYMobileFlyBV"
				flyBV.Parent = T
				flyBV.MaxForce = v3inf
				flyBV.Velocity = v3zero
				flyBG = Instance.new("BodyGyro")
				flyBG.Name = "IYMobileFlyBG"
				flyBG.Parent = T
				flyBG.MaxTorque = v3inf
				flyBG.P = 10000
				flyBG.D = 500
				print("Mobile fly movers re-created on respawn.")
			else
				warn("Failed to re-create mobile fly movers on respawn: RootPart not found.")
				unmobilefly() -- Disable fly if respawn failed
			end
		end
	end)

	print("IY Fly Enabled (Mobile)")
end

--[[ Stops Mobile fly mode ]]
local function unmobilefly()
	FLYING = false
	-- Disconnect listeners
	if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end
	if flyCharacterAddedConnection then flyCharacterAddedConnection:Disconnect(); flyCharacterAddedConnection = nil end

	-- Remove movers
	local currentRootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	if currentRootPart then
		local bv = currentRootPart:FindFirstChild("IYMobileFlyBV")
		local bg = currentRootPart:FindFirstChild("IYMobileFlyBG")
		if bv then bv:Destroy() end
		if bg then bg:Destroy() end
	end
	flyBG = nil
	flyBV = nil

	-- Reset PlatformStand
	if Humanoid then Humanoid.PlatformStand = false end
	print("IY Mobile Fly Disabled")
end

--[[ Toggles Fly mode ON/OFF, choosing PC or Mobile implementation ]]
local function toggleFly()
	-- FLYING = not FLYING -- Toggle state is handled within the start/stop functions now
	print("Fly Toggled. Current State:", FLYING)
	if not FLYING then -- If currently not flying, start flying
		if UserInputService.TouchEnabled then
			mobilefly()
		else
			sFLY()
		end
	else -- If currently flying, stop flying
		if UserInputService.TouchEnabled then
			unmobilefly()
		else
			NOFLY()
		end
	end
    -- Update UI after state change
	updateFlyStatusLabel()
	updateFlyMobileButton()
end

-- Platform Functions
--[[ Creates the platform part if it doesn't exist, or updates its position if needed. ]]
local function createPlatform()
	-- Check if platform exists and is in the workspace
	if platformPartRef and platformPartRef.Parent then
        print("Platform already exists.")
        -- Ensure it's at the correct position (in case TARGET_POSITION_G changes)
        if platformPartRef.Position ~= TARGET_POSITION_G then
            print("Updating existing platform position.")
            platformPartRef.Position = TARGET_POSITION_G -- TARGET_POSITION_G is now R - 6 studs Y
        end
        return -- Exit if already exists
    end
    -- Clear reference if it exists but isn't parented (e.g., destroyed externally)
    if platformPartRef then platformPartRef = nil end

	print("Attempting to create Platform...")
	platformPartRef = Instance.new("Part")
	platformPartRef.Name = "FloatingPlatform_Scripted"
	platformPartRef.Size = PLATFORM_SIZE
	platformPartRef.Position = TARGET_POSITION_G -- Use the (now updated) platform target position
	platformPartRef.Color = PLATFORM_COLOR
	platformPartRef.Material = Enum.Material.Plastic
	platformPartRef.Anchored = PLATFORM_ANCHORED
	-- Set initial visual/collision state based on isPlatformVisible flag
	platformPartRef.Transparency = isPlatformVisible and PLATFORM_TRANSPARENCY_VISIBLE or PLATFORM_TRANSPARENCY_HIDDEN
	platformPartRef.CanCollide = isPlatformVisible and PLATFORM_CAN_COLLIDE or false
    platformPartRef.CanTouch = isPlatformVisible -- Match collision state
    platformPartRef.CanQuery = isPlatformVisible -- Match collision state (for raycasts etc.)
	platformPartRef.Parent = Workspace -- Add to workspace
	print("Platform Created in Workspace at:", TARGET_POSITION_G, "Initial State:", isPlatformVisible and "VISIBLE" or "HIDDEN")
end

--[[ Toggles the platform's visibility and collision state. ]]
local function togglePlatform()
    print("Toggle Platform called. Current state (before toggle):", isPlatformVisible)
	isPlatformVisible = not isPlatformVisible -- Flip the state
    print("Platform state toggled to:", isPlatformVisible and "VISIBLE" or "HIDDEN")

	-- Ensure platform exists, recreate if necessary
	if not platformPartRef or not platformPartRef.Parent then
        warn("Platform part reference lost or destroyed. Recreating...")
		createPlatform() -- Will create at the correct TARGET_POSITION_G
	elseif platformPartRef.Position ~= TARGET_POSITION_G then
        -- If it exists but is somehow at the wrong place, move it
        print("Platform exists but position is outdated. Updating position to:", TARGET_POSITION_G)
        platformPartRef.Position = TARGET_POSITION_G
    end

	-- Update properties of the existing (or newly created) platform
	if platformPartRef and platformPartRef.Parent then
        local targetTransparency = isPlatformVisible and PLATFORM_TRANSPARENCY_VISIBLE or PLATFORM_TRANSPARENCY_HIDDEN
        local targetCollide = isPlatformVisible and PLATFORM_CAN_COLLIDE or false
        local targetTouch = isPlatformVisible -- Match collision
        local targetQuery = isPlatformVisible -- Match collision

		platformPartRef.Transparency = targetTransparency
		platformPartRef.CanCollide = targetCollide
        platformPartRef.CanTouch = targetTouch
        platformPartRef.CanQuery = targetQuery
        print("Platform properties updated: Transparency =", targetTransparency, "CanCollide =", targetCollide)
	else
        warn("Failed to find or create platform part to update properties.")
    end

	-- Update UI labels/buttons
	updatePlatformStatusLabel()
	updatePlatformMobileButton()
end

-- UI Creation Functions
--[[ Gets or creates the main ScreenGui for the controls. ]]
local function getOrCreateScreenGui()
	local screenGui = PlayerGui:FindFirstChild("TeleportControlsScreenGui")
	if not screenGui then
		screenGui = Instance.new("ScreenGui")
		screenGui.Name = "TeleportControlsScreenGui"
		screenGui.ResetOnSpawn = false -- Keep UI across respawns
		screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Use Sibling order
		screenGui.DisplayOrder = 10 -- High display order to be on top
		screenGui.Parent = PlayerGui
	end
	return screenGui
end

--[[ Creates or updates the status labels (top-right). ]]
local function createStatusLabelsUI()
	local screenGui = getOrCreateScreenGui()
	-- Clear existing status labels first
	local children = screenGui:GetChildren()
	for _, child in ipairs(children) do
		if child.Name:match("StatusLabel$") or child.Name:match("Status$") then
			child:Destroy()
		end
	end

	local guiInset = GuiService:GetGuiInset() -- Account for Roblox core UI inset
	-- <<< MODIFIED LINE >>> -- Reduced padding to move labels higher
	local topPadding = 2 -- Was 5
	local labelHeight = 20
	local labelWidth = 150
	local labelSpacing = 5

	-- Helper to create a single status label
	local function createBaseStatusLabel(name, posY)
		local label = Instance.new("TextLabel")
		label.Name = name
		label.Size = UDim2.new(0, labelWidth, 0, labelHeight) -- Pixel size
		label.Position = UDim2.new(1, -labelWidth - 10, 0, posY) -- Position from top-right
		label.BackgroundTransparency = 0.8
		label.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Black background
		label.BorderSizePixel = 0
		label.Font = Enum.Font.SourceSansBold
		label.TextSize = 14
		label.TextXAlignment = Enum.TextXAlignment.Center
		label.Parent = screenGui
		return label
	end

	-- Create labels vertically, updating Y position
	local currentY = topPadding + guiInset.Y
	antiFallStatusLabelRef = createBaseStatusLabel("AntiFallStatusLabel", currentY); updateAntiFallStatusLabel()
	currentY = currentY + labelHeight + labelSpacing
	gFuncStatusLabelRef = createBaseStatusLabel("GStatusLabel", currentY); updateGFuncStatusLabel()
	currentY = currentY + labelHeight + labelSpacing
	hFuncStatusLabelRef = createBaseStatusLabel("HStatusLabel", currentY); updateHFuncStatusLabel()
	currentY = currentY + labelHeight + labelSpacing
	flyStatusLabelRef = createBaseStatusLabel("FlyStatusLabel", currentY); updateFlyStatusLabel()
	currentY = currentY + labelHeight + labelSpacing
	platformStatusLabelRef = createBaseStatusLabel("PlatformStatusLabel", currentY); updatePlatformStatusLabel()

	print("Status Labels UI created/updated.")
end

--[[ Creates or updates the keybinds info label (PC only). ]]
local function createKeybindsLabelUI()
	local screenGui = getOrCreateScreenGui()
	-- Remove old label if exists
	local oldLabel = screenGui:FindFirstChild("KeybindsLabel")
	if oldLabel then oldLabel:Destroy() end

	local guiInset = GuiService:GetGuiInset()
	-- <<< MODIFIED LINE >>> -- Match status label padding
	local topPadding = 2 -- Was 5
	local labelHeight = 110 -- Taller to fit more text
	local labelWidth = 150

	-- Calculate position below the status labels
	local statusBlockBottomY = topPadding + guiInset.Y
    -- Use AbsolutePosition/Size for accurate positioning relative to dynamic status labels
    if platformStatusLabelRef and platformStatusLabelRef.Parent then
		statusBlockBottomY = platformStatusLabelRef.AbsolutePosition.Y + platformStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif flyStatusLabelRef and flyStatusLabelRef.Parent then
        statusBlockBottomY = flyStatusLabelRef.AbsolutePosition.Y + flyStatusLabelRef.AbsoluteSize.Y - guiInset.Y
    elseif hFuncStatusLabelRef and hFuncStatusLabelRef.Parent then
		statusBlockBottomY = hFuncStatusLabelRef.AbsolutePosition.Y + hFuncStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif gFuncStatusLabelRef and gFuncStatusLabelRef.Parent then
		statusBlockBottomY = gFuncStatusLabelRef.AbsolutePosition.Y + gFuncStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif antiFallStatusLabelRef and antiFallStatusLabelRef.Parent then
		statusBlockBottomY = antiFallStatusLabelRef.AbsolutePosition.Y + antiFallStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	end

	local keybindsLabelYOffset = statusBlockBottomY + 10 -- Add padding below status labels

	-- Create the label
	local keybindsLabel = Instance.new("TextLabel")
	keybindsLabel.Name = "KeybindsLabel"
	keybindsLabel.Size = UDim2.new(0, labelWidth, 0, labelHeight)
	keybindsLabel.Position = UDim2.new(1, -labelWidth - 10, 0, keybindsLabelYOffset) -- Position below status labels
	keybindsLabel.BackgroundTransparency = 0.8
	keybindsLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	keybindsLabel.BorderSizePixel = 0
	keybindsLabel.Font = Enum.Font.SourceSans
	keybindsLabel.TextSize = 12
	keybindsLabel.TextColor3 = Color3.fromRGB(200, 200, 200) -- Light grey text
	keybindsLabel.TextWrapped = true -- Allow text wrapping
	keybindsLabel.TextXAlignment = Enum.TextXAlignment.Left
	keybindsLabel.TextYAlignment = Enum.TextYAlignment.Top
	-- Format the keybind text string
	-- <<< MODIFIED LINE >>> -- Changed E description back
	keybindsLabel.Text = string.format(
        "%s: other parts\n%s: Troll button\n%s: TP To Location\n%s: Toggle AntiFall\n%s: Toggle Troll Detect\n%s: Toggle Other Detect\n%s: Toggle Fly\n%s: Toggle Platform",
        TRIGGER_KEY_Q.Name, TRIGGER_KEY_E.Name, TRIGGER_KEY_R.Name, TRIGGER_KEY_F.Name,
        TRIGGER_KEY_G.Name, TRIGGER_KEY_H.Name, TRIGGER_KEY_FLY.Name, TRIGGER_KEY_PLATFORM.Name
    )
	keybindsLabel.Parent = screenGui
	keybindsLabelRef = keybindsLabel -- Store reference
	print("Keybinds Info UI created/updated.")
end

--[[ Creates or updates the mobile control buttons and toggle. ]]
local function createMobileUI()
	local screenGui = getOrCreateScreenGui()
	-- Clear previous mobile UI elements
	local oldFrame = screenGui:FindFirstChild("ButtonFrame")
	if oldFrame then oldFrame:Destroy() end
	local oldToggle = screenGui:FindFirstChild("ToggleButton")
	if oldToggle then oldToggle:Destroy() end

	local guiInset = GuiService:GetGuiInset()
	-- <<< MODIFIED LINE >>> -- Match status label padding
	local topPadding = 2 -- Was 5

	-- Button layout configuration
	local buttonWidth = 80
	local buttonHeight = 35
	local buttonPadding = 5
	local buttonsPerRow = 4
	local numRows = 2

	-- Calculate frame size based on buttons
	local frameWidth = (buttonWidth * buttonsPerRow) + (buttonPadding * (buttonsPerRow - 1))
	local frameHeight = (buttonHeight * numRows) + (buttonPadding * (numRows - 1))

	-- Create the main frame for buttons
	local buttonFrame = Instance.new("Frame")
	buttonFrame.Name = "ButtonFrame"
	buttonFrame.BackgroundTransparency = 1 -- Invisible frame background
	buttonFrame.Size = UDim2.new(0, frameWidth, 0, frameHeight)
	buttonFrame.Visible = true -- Initially visible
	buttonFrame.Parent = screenGui

	-- Helper to create a single mobile button
	local function createMobileButton(name, text, rowIndex, colIndex, color, borderColor, clickFunction)
		local button = Instance.new("TextButton")
		button.Name = name
		button.Text = text
		button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
		-- Calculate position within the frame grid
		local posX = (buttonWidth + buttonPadding) * colIndex
		local posY = (buttonHeight + buttonPadding) * rowIndex
		button.Position = UDim2.new(0, posX, 0, posY)
		button.BackgroundColor3 = color
		button.BorderColor3 = borderColor
		button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
		button.Font = Enum.Font.SourceSansBold
		button.TextSize = 13
		button.TextWrapped = true -- Allow text wrapping for longer names
		button.Parent = buttonFrame
		-- Connect click event if provided
		if clickFunction then
			button.MouseButton1Click:Connect(clickFunction)
		end
		return button
	end

	-- Create all the mobile buttons and store references
	local buttonQ = createMobileButton("TeleportButtonQ", "Q: other parts", 0, 0, Color3.fromRGB(80, 80, 200), Color3.fromRGB(20, 20, 50), function() handlePartTeleport(TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "Button Q") end)
	-- <<< MODIFIED LINE >>> -- Changed button text back
	local buttonE = createMobileButton("TeleportButtonE", "E: Troll button", 0, 1, Color3.fromRGB(200, 80, 80), Color3.fromRGB(50, 20, 20), function() handlePartTeleport(TARGET_PART_NAME_E, TELEPORT_DURATION_E, "Button E") end)
	local buttonR = createMobileButton("TeleportButtonR", "R: TP Loc", 0, 2, Color3.fromRGB(80, 200, 80), Color3.fromRGB(20, 50, 20), function() teleportPlayerToCoords(TARGET_POSITION_R, "Button R") end)
	antiFallButtonRef = createMobileButton("AntiFallButton", "F: AntiFall", 0, 3, Color3.fromRGB(200, 50, 50), Color3.fromRGB(30, 30, 30), toggleAntiFall)

	gFuncButtonRef = createMobileButton("DetectButtonG", "G: Troll Detect", 1, 0, Color3.fromRGB(200, 50, 50), Color3.fromRGB(30, 30, 30), toggleGFunc)
	hFuncButtonRef = createMobileButton("DetectButtonH", "H: Other Detect", 1, 1, Color3.fromRGB(200, 50, 50), Color3.fromRGB(30, 30, 30), toggleHFunc)
	flyButtonRef = createMobileButton("FlyButton", "X: Fly", 1, 2, Color3.fromRGB(200, 50, 50), Color3.fromRGB(30, 30, 30), toggleFly)
	platformButtonRef = createMobileButton("PlatformButton", "P: Platform", 1, 3, Color3.fromRGB(200, 50, 50), Color3.fromRGB(30, 30, 30), togglePlatform)

	-- Create the toggle button ('>' / '<')
	local toggleButton = Instance.new("TextButton")
	toggleButton.Name = "ToggleButton"
	toggleButton.Text = ">" -- Initial text
	toggleButton.Size = UDim2.new(0, 30, 0, buttonHeight) -- Small width, same height as other buttons

	-- Calculate position below status labels (similar to keybinds label)
	local lowestLabelY = topPadding + guiInset.Y
    -- Use AbsolutePosition/Size for accurate positioning
	if platformStatusLabelRef and platformStatusLabelRef.Parent then
		lowestLabelY = platformStatusLabelRef.AbsolutePosition.Y + platformStatusLabelRef.AbsoluteSize.Y - guiInset.Y
    elseif flyStatusLabelRef and flyStatusLabelRef.Parent then
        lowestLabelY = flyStatusLabelRef.AbsolutePosition.Y + flyStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif hFuncStatusLabelRef and hFuncStatusLabelRef.Parent then
		lowestLabelY = hFuncStatusLabelRef.AbsolutePosition.Y + hFuncStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif gFuncStatusLabelRef and gFuncStatusLabelRef.Parent then
		lowestLabelY = gFuncStatusLabelRef.AbsolutePosition.Y + gFuncStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	elseif antiFallStatusLabelRef and antiFallStatusLabelRef.Parent then
		lowestLabelY = antiFallStatusLabelRef.AbsolutePosition.Y + antiFallStatusLabelRef.AbsoluteSize.Y - guiInset.Y
	end
	local toggleYOffset = lowestLabelY + 10 -- Add padding

	toggleButton.Position = UDim2.new(1, -45, 0, toggleYOffset) -- Position near top-right, below labels
	toggleButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100) -- Grey background
	toggleButton.BorderColor3 = Color3.fromRGB(50, 50, 50)
	toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	toggleButton.Font = Enum.Font.SourceSansBold
	toggleButton.TextSize = 24
	toggleButton.AutoButtonColor = false -- Disable default button color changes
	toggleButton.Parent = screenGui
	uiToggleButtonRef = toggleButton -- Store reference

	-- Function to update the button frame's position relative to the toggle button
	local function updateFramePosition()
        task.wait() -- Wait a frame for size calculations to be accurate
		buttonFrame.Position = UDim2.new(
			toggleButton.Position.X.Scale, toggleButton.Position.X.Offset - buttonFrame.AbsoluteSize.X - 10, -- Position left of toggle button
			toggleButton.Position.Y.Scale, toggleButton.Position.Y.Offset -- Align vertically with toggle button
		)
	end

	-- Initial setup
	updateFramePosition()
	updateAntiFallMobileButton()
	updateGFuncMobileButton()
	updateHFuncMobileButton()
	updateFlyMobileButton()
	updatePlatformMobileButton()

	-- Drag and Toggle Logic for the mobile UI toggle button
	local dragging = false
	local dragInput = nil
	local dragStart = nil
	local startPos = nil

	-- Handle input start (click or touch)
	toggleButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position -- Record starting mouse/touch position
			startPos = toggleButton.Position -- Record starting UI position
			dragInput = input -- Store the specific input object

			-- Handle input end (release) within a Changed connection for robustness
			local connection
			connection = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					-- If dragging ended and it was a short movement (click/tap)
					if dragging and (input.Position - dragStart).Magnitude < 5 then
						buttonFrame.Visible = not buttonFrame.Visible -- Toggle frame visibility
						toggleButton.Text = buttonFrame.Visible and ">" or "<" -- Update toggle text
						if buttonFrame.Visible then
							updateFramePosition() -- Reposition frame if it became visible
						end
					end
					-- Reset dragging state
					dragging = false
					dragInput = nil
					if connection then connection:Disconnect() end -- Disconnect this Changed listener
				end
			end)
		end
	end)

	-- Handle input movement (mouse or touch drag)
	toggleButton.InputChanged:Connect(function(input)
		if input == dragInput and dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			-- Only start dragging UI if moved beyond a small threshold
			if (input.Position - dragStart).Magnitude >= 5 then
				local delta = input.Position - dragStart -- Calculate movement delta
				-- Update toggle button position based on drag
				toggleButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				updateFramePosition() -- Keep the frame positioned relative to the toggle
			end
		end
	end)

	-- Handle input end globally (fallback in case Changed event doesn't fire)
	UserInputService.InputEnded:Connect(function(input)
		if input == dragInput and dragging then
			dragging = false
			dragInput = nil
		end
	end)

	print("Mobile controls UI created/updated.")
end

--[[ Hides initial Q parts on script start (seems optional/game-specific). ]]
--[[ Commented out as it might not be universally desired
local function hideInitialParts()
	print("Hiding initial Q parts...")
	local partsHidden = 0
	for _, descendant in ipairs(Workspace:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant.Name == TARGET_PART_NAME_Q then
			setVisibilityRecursive(descendant, false, {}) -- Hide without storing state
			partsHidden = partsHidden + 1
		end
	end
	print("Finished hiding initial Q parts. Count:", partsHidden)
end
--]]

--[[ Creates or updates the detection zone visualizer parts. ]]
local function createDetectionVisualizers()
	-- G Zone Visualizer
	if not gVisualizerPartRef or not gVisualizerPartRef.Parent then
        if gVisualizerPartRef then gVisualizerPartRef:Destroy() end -- Clean up old one if reference exists but part doesn't
		local sphereG = Instance.new("Part")
		sphereG.Name = "G_DetectionZoneVisualizer"
		sphereG.Shape = Enum.PartType.Ball
		sphereG.Size = Vector3.new(DETECTION_RADIUS_G*2, DETECTION_RADIUS_G*2, DETECTION_RADIUS_G*2) -- Diameter = Radius * 2
		sphereG.Position = DETECT_POSITION_G -- Use updated position
		sphereG.Color = Color3.fromRGB(0, 255, 255) -- Cyan
		sphereG.Material = Enum.Material.ForceField -- Semi-transparent material
		sphereG.Transparency = 0.7
		sphereG.Anchored = true
		sphereG.CanCollide = false
		sphereG.CanTouch = false
		sphereG.CanQuery = false -- Ignore for raycasts etc.
		sphereG.Visible = isGFuncEnabled -- Initial visibility based on toggle state
		sphereG.Parent = Workspace
		gVisualizerPartRef = sphereG
		print("G Detection Visualizer Created at:", DETECT_POSITION_G)
    elseif gVisualizerPartRef.Position ~= DETECT_POSITION_G then
        -- Update position if DETECT_POSITION_G somehow changes
        print("Updating G Visualizer position to:", DETECT_POSITION_G)
        gVisualizerPartRef.Position = DETECT_POSITION_G -- Update if needed
	end

	-- H Zone Visualizer
	if not hVisualizerPartRef or not hVisualizerPartRef.Parent then
        if hVisualizerPartRef then hVisualizerPartRef:Destroy() end
		local sphereH = Instance.new("Part")
		sphereH.Name = "H_DetectionZoneVisualizer"
		sphereH.Shape = Enum.PartType.Ball
		sphereH.Size = Vector3.new(DETECTION_RADIUS_H*2, DETECTION_RADIUS_H*2, DETECTION_RADIUS_H*2)
		sphereH.Position = TARGET_POSITION_H -- Use updated position
		sphereH.Color = Color3.fromRGB(255, 255, 0) -- Yellow
		sphereH.Material = Enum.Material.ForceField
		sphereH.Transparency = 0.7
		sphereH.Anchored = true
		sphereH.CanCollide = false
		sphereH.CanTouch = false
		sphereH.CanQuery = false
		sphereH.Visible = isHFuncEnabled -- Initial visibility
		sphereH.Parent = Workspace
		hVisualizerPartRef = sphereH
		print("H Detection Visualizer Created at:", TARGET_POSITION_H)
    elseif hVisualizerPartRef.Position ~= TARGET_POSITION_H then
         print("Updating H Visualizer position to:", TARGET_POSITION_H)
         hVisualizerPartRef.Position = TARGET_POSITION_H -- Update if needed
	end

	-- Clean up visualizers, platform, and fly state when character is removed (avoids duplicates on respawn)
	LocalPlayer.CharacterRemoving:Connect(function(removedCharacter)
        print("CharacterRemoving event fired.")
		if gVisualizerPartRef and gVisualizerPartRef.Parent then gVisualizerPartRef:Destroy() end
        gVisualizerPartRef = nil
		if hVisualizerPartRef and hVisualizerPartRef.Parent then hVisualizerPartRef:Destroy() end
        hVisualizerPartRef = nil
		if platformPartRef and platformPartRef.Parent then platformPartRef:Destroy() end
        platformPartRef = nil
        -- Stop flying cleanly if character is removed while flying
        if FLYING then
            if UserInputService.TouchEnabled then unmobilefly() else NOFLY() end
        end
        print("Cleaned up visualizers, platform, and fly state.")
	end)
end

-- Main Loops and Event Connections
--[[ RenderStepped loop for Anti-Fall check. ]]
RunService.RenderStepped:Connect(function(deltaTime)
	if isAntiFallEnabled then
		local currentTime = tick() -- Use tick() for simple time checks
		-- Check if cooldown has passed
		if currentTime - lastAntiFallTime >= ANTI_FALL_COOLDOWN then
			local player = LocalPlayer
			local character = player.Character
			if character then
				local currentRootPart = character:FindFirstChild("HumanoidRootPart")
				if currentRootPart then
					-- Check if player is below the threshold
					if currentRootPart.Position.Y < ANTI_FALL_Y_THRESHOLD then
						print("Anti-Fall triggered!")
						teleportPlayerToCoords(TARGET_POSITION_R, "Anti-Fall")
						lastAntiFallTime = currentTime -- Update last trigger time
					end
				end
			end
		end
	end
end)

--[[ Background loop to detect players near G zone and trigger E action. ]]
local function detectNearbyPlayersAndTriggerE_Loop()
	while task.wait(0.1) do -- Check every 0.1 seconds
		-- Only run if G detection is enabled and no part teleport is happening
		if isGFuncEnabled and not isPartTeleporting then
			local currentTime = tick()
			-- Check cooldown
			if currentTime - lastPlayerDetectTime_G >= PLAYER_DETECT_COOLDOWN_G then
				local localPlayer = LocalPlayer
				local localChar = localPlayer.Character
				if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then continue end -- Skip if local player char/rootpart is missing

				local localRootPos = localChar.HumanoidRootPart.Position
				local foundTarget = false
				-- Iterate through all players
				for _, player in ipairs(Players:GetPlayers()) do
					if player ~= localPlayer then -- Ignore self
						local character = player.Character
						if character then
							local hrp = character:FindFirstChild("HumanoidRootPart")
							if hrp then
								-- Calculate distance between detection zone center and other player's root part
								local distance = (hrp.Position - DETECT_POSITION_G).Magnitude -- Use updated G position
								if distance <= DETECTION_RADIUS_G then
									print("DEBUG: Player '"..player.Name.."' detected near G (Dist: "..string.format("%.2f", distance).."). Triggering 'button' parts (E).") -- Log still mentions 'button' parts internally
									-- Spawn teleport in new thread to avoid yielding the loop
									task.spawn(handlePartTeleport, TARGET_PART_NAME_E, TELEPORT_DURATION_E, "G Detection")
									lastPlayerDetectTime_G = currentTime -- Update cooldown timestamp
									foundTarget = true
									break -- Stop checking other players once one is found
								end
                            end
                        end
					end
				end
            end
		end
	end
end

--[[ Background loop to detect players near H zone and trigger Q action. ]]
local function detectNearbyPlayersAndTriggerQ_Loop()
	while task.wait(0.1) do -- Check every 0.1 seconds
		-- Only run if H detection is enabled and no part teleport is happening
		if isHFuncEnabled and not isPartTeleporting then
			local currentTime = tick()
			-- Check cooldown
			if currentTime - lastPlayerDetectTime_H >= PLAYER_DETECT_COOLDOWN_H then
				local localPlayer = LocalPlayer
				local localChar = localPlayer.Character
				if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then continue end -- Skip if local player char/rootpart is missing

				local localRootPos = localChar.HumanoidRootPart.Position
				local foundTarget = false
				-- Iterate through all players
				for _, player in ipairs(Players:GetPlayers()) do
					if player ~= localPlayer then -- Ignore self
						local character = player.Character
						if character then
							local hrp = character:FindFirstChild("HumanoidRootPart")
							if hrp then
								-- Calculate distance between H zone center and other player's root part
								local distance = (hrp.Position - TARGET_POSITION_H).Magnitude -- Use updated H position
								if distance <= DETECTION_RADIUS_H then
									print("Player '"..player.Name.."' detected near H (Dist: "..string.format("%.2f", distance).."). Triggering other parts (Q).")
									-- Spawn teleport in new thread
									task.spawn(handlePartTeleport, TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "H Detection")
									lastPlayerDetectTime_H = currentTime -- Update cooldown timestamp
									foundTarget = true
									break -- Stop checking
								end
							end
						end
					end
				end
			end
		end
	end
end

-- Initialization Block
-- Use pcall to catch errors during initial UI/World setup
local uiSuccess, uiError = pcall(function()
    print("Initializing UI and World Objects...")
	createStatusLabelsUI() -- Create status labels first
	if not UserInputService.TouchEnabled then
		createKeybindsLabelUI() -- Create keybinds label only on PC
	end
	if UserInputService.TouchEnabled then
		createMobileUI() -- Create mobile buttons only on Touch devices
	end
	createDetectionVisualizers() -- Create visualizer parts
    createPlatform() -- Create the platform part (initially hidden or visible based on default)
    -- hideInitialParts() -- Call if needed
    print("Initialization complete.")
end)
if not uiSuccess then
	warn("Error during UI/World Initialization:", uiError)
end

-- Start Detection Loops
task.spawn(detectNearbyPlayersAndTriggerE_Loop)
task.spawn(detectNearbyPlayersAndTriggerQ_Loop)
print("Detection loops started.")

-- Connect Keyboard Input Handler
-- Use pcall to catch errors during input connection setup
local inputSuccess, inputError = pcall(function()
    -- Ensure previous fly connections are disconnected before reconnecting main input
    if flyKeyDownConnection then flyKeyDownConnection:Disconnect(); flyKeyDownConnection = nil end
    if flyKeyUpConnection then flyKeyUpConnection:Disconnect(); flyKeyUpConnection = nil end

	UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
		-- Ignore input if user is typing in a textbox or interacting with core UI
		if gameProcessedEvent then return end
        -- If flying, only allow the Fly toggle key itself
        if FLYING and input.KeyCode ~= TRIGGER_KEY_FLY then return end

		local keyCode = input.KeyCode

		-- Check which key was pressed and call the corresponding function using pcall for safety
		if keyCode == TRIGGER_KEY_Q then
            print("Q Key Pressed (other parts)")
			pcall(handlePartTeleport, TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "Q Key")
		elseif keyCode == TRIGGER_KEY_E then
            print("E Key Pressed (Troll button)") -- Log reflects UI text change
			pcall(handlePartTeleport, TARGET_PART_NAME_E, TELEPORT_DURATION_E, "E Key")
		elseif keyCode == TRIGGER_KEY_R then
            print("R Key Pressed")
			pcall(teleportPlayerToCoords, TARGET_POSITION_R, "R Key")
		elseif keyCode == TRIGGER_KEY_F then
            print("F Key Pressed")
			pcall(toggleAntiFall)
		elseif keyCode == TRIGGER_KEY_G then
            print("G Key Pressed")
			pcall(toggleGFunc)
		elseif keyCode == TRIGGER_KEY_H then
            print("H Key Pressed")
			pcall(toggleHFunc)
		elseif keyCode == TRIGGER_KEY_FLY then
            print("X Key Pressed")
            pcall(toggleFly)
        elseif keyCode == TRIGGER_KEY_PLATFORM then
            print("P Key Pressed")
            pcall(togglePlatform)
		end
	end)
end)
if not inputSuccess then
	warn("Error connecting Input Handler:", inputError)
else
	print("Teleporting, Anti-Fall, Player Detect, Fly & Platform script input handler loaded. Keys: Q, E, R, F, G, H, X, P.")
end

-- Handle Character Respawn
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    print("CharacterAdded event fired. Updating references and recreating objects.")
    task.wait(0.2) -- Short delay to allow character components to load
    Character = newCharacter -- Update global character reference
    local success
    -- Safely get Humanoid and HumanoidRootPart with timeouts
    success = pcall(function() Humanoid = newCharacter:WaitForChild("Humanoid", 10) end)
    if not success or not Humanoid then warn("Failed to get Humanoid on respawn.") return end -- Stop if failed
    success = pcall(function() HumanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart", 10) end)
    if not success or not HumanoidRootPart then warn("Failed to get HumanoidRootPart on respawn.") return end -- Stop if failed

    print("Character references updated.")

    -- Re-apply fly state if it was active before respawn
    if FLYING then
        print("Re-applying fly state after respawn.")
        task.wait(0.5) -- Extra delay before starting fly
        if UserInputService.TouchEnabled then
            mobilefly()
        else
            sFLY()
        end
    end
    -- Recreate world objects and UI elements for the new character/session
    createDetectionVisualizers() -- Will update visualizer positions
    createPlatform() -- Recreates platform if needed
    createStatusLabelsUI() -- Refresh UI (will use new padding)
    if not UserInputService.TouchEnabled then createKeybindsLabelUI() end -- Refresh UI (will use new text/padding)
    if UserInputService.TouchEnabled then createMobileUI() end -- Refresh UI (will use new text/padding)
    print("Respawn setup complete.")
end)

