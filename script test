-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService") -- Needed for Rayfield check

-- Player specific variables
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Configuration Variables
local TARGET_PART_NAME_Q = "사라지는 파트"
local TELEPORT_DURATION_Q = 0.1
local TRIGGER_KEY_Q = Enum.KeyCode.Q

local TARGET_PART_NAME_E = "Gudock"
local TELEPORT_DURATION_E = 0.1
local TRIGGER_KEY_E = Enum.KeyCode.E

local TRIGGER_KEY_R = Enum.KeyCode.R
local TARGET_POSITION_R = Vector3.new(-76.9988251, 147.146271, -75.000618)

local TRIGGER_KEY_F = Enum.KeyCode.F
local ANTI_FALL_Y_THRESHOLD = TARGET_POSITION_R.Y - 50
local ANTI_FALL_COOLDOWN = 1

local TRIGGER_KEY_G = Enum.KeyCode.G
local DETECT_POSITION_G = Vector3.new(-41.8089943, 147.146271, -80.9691467)
local TARGET_POSITION_G = Vector3.new(-41.8089943, 147.146271 - 7, -80.9691467)
local DETECTION_RADIUS_G = 5
local PLAYER_DETECT_COOLDOWN_G = 0.5

local TRIGGER_KEY_H = Enum.KeyCode.H
local TARGET_POSITION_H = Vector3.new(-78.8984604, 147.146271, -39.3039017)
local DETECTION_RADIUS_H = 15
local PLAYER_DETECT_COOLDOWN_H = PLAYER_DETECT_COOLDOWN_G

local TRIGGER_KEY_FLY = Enum.KeyCode.X
local FLYING = false
local QEfly = true
local iyflyspeed = 1
local vehicleflyspeed = 1
local flyKeyDownConnection = nil
local flyKeyUpConnection = nil
local flyRenderStepConnection = nil
local flyCharacterAddedConnection = nil

local TRIGGER_KEY_PLATFORM = Enum.KeyCode.P
local PLATFORM_SIZE = Vector3.new(200, 5, 200)
local PLATFORM_COLOR = Color3.fromRGB(100, 200, 255)
local PLATFORM_TRANSPARENCY_VISIBLE = 0.5
local PLATFORM_TRANSPARENCY_HIDDEN = 1
local PLATFORM_ANCHORED = true
local PLATFORM_CAN_COLLIDE = true
local isPlatformVisible = false
local platformPartRef = nil

-- State Variables
local isPartTeleporting = false
local originalStateData = {}
local isAntiFallEnabled = false
local lastAntiFallTime = 0
local isGFuncEnabled = false
local lastPlayerDetectTime_G = 0
local isHFuncEnabled = false
local lastPlayerDetectTime_H = 0

-- Rayfield UI References (Optional, for potential external updates)
local antiFallToggleRef = nil
local gFuncToggleRef = nil
local hFuncToggleRef = nil
local flyToggleRef = nil
local platformToggleRef = nil

-- Rayfield Library Loading
local Rayfield = nil
local success, errorMsg = pcall(function()
    Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
end)

if not success or not Rayfield then
    warn("Failed to load Rayfield library:", errorMsg)
    -- Optionally notify the user or fallback to a simpler UI if needed
    LocalPlayer:Kick("Failed to load required UI library. Please ensure you have internet access.")
    return
end

-- Utility Functions (Keep necessary ones)
local function getRoot(char)
	local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
	return rootPart
end

local function setVisibilityRecursive(instance, visible, stateStore)
	if not instance then return end
	local originalProps = {}
	if instance:IsA("BasePart") then
		originalProps.Transparency = instance.Transparency
		instance.Transparency = visible and originalProps.Transparency or 1
	end
	if instance:IsA("Decal") or instance:IsA("Texture") then
		originalProps.Transparency = instance.Transparency
		instance.Transparency = visible and originalProps.Transparency or 1
	end
	if instance:IsA("SurfaceGui") or instance:IsA("ParticleEmitter") or instance:IsA("PointLight") or instance:IsA("SpotLight") or instance:IsA("SurfaceLight") or instance:IsA("Highlight") then
		originalProps.Enabled = instance.Enabled
		instance.Enabled = visible and originalProps.Enabled or false
	end
	if not visible and next(originalProps) then
		stateStore[instance] = originalProps
	end
	for _, child in ipairs(instance:GetChildren()) do
		setVisibilityRecursive(child, visible, stateStore)
	end
end

local function handlePartTeleport(targetPartName, teleportDuration, triggerSource)
	if isPartTeleporting then print("Part teleport already in progress (requested by " .. triggerSource .. ")."); return end
	local player = LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local currentHumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not currentHumanoidRootPart then warn("HumanoidRootPart not found (" .. triggerSource .. ")."); return end

	print(triggerSource .. " action triggered, searching for parts named:", targetPartName)
	isPartTeleporting = true
	originalStateData = {}
	local partsToTeleport = {}
	local foundParts = false

	for _, descendant in ipairs(Workspace:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant.Name == targetPartName then
			table.insert(partsToTeleport, descendant)
			originalStateData[descendant] = {
				main = { CFrame = descendant.CFrame, Anchored = descendant.Anchored, CanCollide = descendant.CanCollide },
				children = {}
			}
			foundParts = true
		end
	end

	if foundParts then
		print("Found", #partsToTeleport, "parts via " .. triggerSource .. ". Teleporting them...")
		local targetCFrame = currentHumanoidRootPart.CFrame

		for _, part in ipairs(partsToTeleport) do
			if part and part.Parent and originalStateData[part] then
				part.Anchored = true
				part.CanCollide = false
				if targetPartName == TARGET_PART_NAME_E and triggerSource ~= "H Detection" then
					setVisibilityRecursive(part, false, originalStateData[part].children)
				end
				part.CFrame = targetCFrame
			end
		end

		task.wait(teleportDuration)
		print("Returning parts triggered by " .. triggerSource .. "...")

		for _, part in ipairs(partsToTeleport) do
			if part and part.Parent and originalStateData[part] then
				local originalMainData = originalStateData[part].main
				local originalChildrenData = originalStateData[part].children

				part.CFrame = originalMainData.CFrame
				part.Anchored = originalMainData.Anchored
				part.CanCollide = originalMainData.CanCollide

				if targetPartName == TARGET_PART_NAME_E and triggerSource ~= "H Detection" then
					for instance, props in pairs(originalChildrenData) do
						if instance and instance.Parent then
							for propName, originalValue in pairs(props) do
								pcall(function() instance[propName] = originalValue end)
							end
						end
					end
                    if originalChildrenData[part] and originalChildrenData[part].Transparency then
                        pcall(function() part.Transparency = originalChildrenData[part].Transparency end)
                    elseif originalStateData[part] and originalStateData[part].children[part] then
                        pcall(function() part.Transparency = originalStateData[part].children[part].Transparency end)
                    else
                        pcall(function() part.Transparency = 0 end)
                    end
				end
			end
		end
		print("Parts return complete for " .. triggerSource .. ".")
	else
		print("No parts found with the name '" .. targetPartName .. "' for trigger " .. triggerSource)
	end

	isPartTeleporting = false
	originalStateData = {}
end

local function teleportPlayerToCoords(targetPosition, triggerSource)
	local player = LocalPlayer
	local character = player.Character
	if not character then warn("Player character not found (" .. triggerSource .. ")."); return end
	local currentHumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not currentHumanoidRootPart then warn("HumanoidRootPart not found (" .. triggerSource .. ")."); return end

	print(triggerSource .. " action triggered, teleporting player to:", targetPosition)
	currentHumanoidRootPart.CFrame = CFrame.new(targetPosition)
end

-- Toggle Functions (Modified for Rayfield potentially)
local function toggleAntiFall()
	isAntiFallEnabled = not isAntiFallEnabled
	print("Anti-Fall Toggled:", isAntiFallEnabled and "ON" or "OFF")
	-- Rayfield toggle might update automatically, if not, update here:
	-- if antiFallToggleRef then antiFallToggleRef:Set(isAntiFallEnabled) end
end
local function toggleGFunc()
	isGFuncEnabled = not isGFuncEnabled
	print("Player Detection (G -> E) Toggled:", isGFuncEnabled and "ON" or "OFF")
	if gVisualizerPartRef then gVisualizerPartRef.Visible = isGFuncEnabled end
	-- if gFuncToggleRef then gFuncToggleRef:Set(isGFuncEnabled) end
end
local function toggleHFunc()
	isHFuncEnabled = not isHFuncEnabled
	print("Player Detection (H -> Q) Toggled:", isHFuncEnabled and "ON" or "OFF")
	if hVisualizerPartRef then hVisualizerPartRef.Visible = isHFuncEnabled end
	-- if hFuncToggleRef then hFuncToggleRef:Set(isHFuncEnabled) end
end

-- Fly Logic (IY Style)
local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
local SPEED = 0
local flyBG = nil
local flyBV = nil

local function NOFLY()
	FLYING = false
	if flyKeyDownConnection then flyKeyDownConnection:Disconnect(); flyKeyDownConnection = nil end
	if flyKeyUpConnection then flyKeyUpConnection:Disconnect(); flyKeyUpConnection = nil end
	local currentRootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	if currentRootPart then
		if flyBG and flyBG.Parent == currentRootPart then flyBG:Destroy() end
		if flyBV and flyBV.Parent == currentRootPart then flyBV:Destroy() end
	end
	flyBG = nil
	flyBV = nil

	if Humanoid then Humanoid.PlatformStand = false end
	pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
	print("IY Fly Disabled")
end

local function sFLY(vfly)
	if FLYING then NOFLY() end
	wait()
	if not Character or not Humanoid or not HumanoidRootPart then print("Cannot start fly: Character components missing."); return end

	FLYING = true
	local T = HumanoidRootPart

	if flyBG and flyBG.Parent then flyBG:Destroy() end
	if flyBV and flyBV.Parent then flyBV:Destroy() end

	flyBG = Instance.new('BodyGyro')
	flyBG.P = 9e4
	flyBG.Parent = T
	flyBG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
	flyBG.cframe = T.CFrame

	flyBV = Instance.new('BodyVelocity')
	flyBV.Parent = T
	flyBV.velocity = Vector3.new(0, 0, 0)
	flyBV.maxForce = Vector3.new(9e9, 9e9, 9e9)

	CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	SPEED = 0

	task.spawn(function()
		local flyLoopActive = true
		local connection = RunService.Heartbeat:Connect(function()
			if not FLYING or not flyBV or not flyBV.Parent or not flyBG or not flyBG.Parent then
				flyLoopActive = false
				return
			end
			if Humanoid then Humanoid.PlatformStand = true end

			if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
				SPEED = 50
			elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
				SPEED = 0
			end

			local currentSpeed = (vfly and vehicleflyspeed or iyflyspeed)

			if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
				local camFrame = workspace.CurrentCamera.CFrame
				local lookVector = camFrame.lookVector
				local rightVector = camFrame.rightVector
				local upVector = camFrame.upVector

				local moveDir = (lookVector * (CONTROL.F + CONTROL.B)) + (rightVector * (CONTROL.L + CONTROL.R))
				local verticalDir = Vector3.new(0, (CONTROL.Q + CONTROL.E), 0)

				flyBV.velocity = (moveDir + verticalDir) * SPEED * currentSpeed
				lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}

			elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
				local camFrame = workspace.CurrentCamera.CFrame
				local lookVector = camFrame.lookVector
				local rightVector = camFrame.rightVector
				local moveDir = (lookVector * (lCONTROL.F + lCONTROL.B)) + (rightVector * (lCONTROL.L + lCONTROL.R))
				flyBV.velocity = moveDir * SPEED * currentSpeed
				flyBV.velocity = Vector3.new(0,0,0)
				SPEED = 0
			else
				flyBV.velocity = Vector3.new(0, 0, 0)
			end
			flyBG.cframe = workspace.CurrentCamera.CFrame
		end)

		while flyLoopActive do wait() end
		connection:Disconnect()
		print("Fly Heartbeat loop stopped.")
	end)

	if flyKeyDownConnection then flyKeyDownConnection:Disconnect() end
	flyKeyDownConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or not FLYING then return end
		local KEY = input.KeyCode.Name:lower()
		if KEY == 'w' then CONTROL.F = 1
		elseif KEY == 's' then CONTROL.B = -1
		elseif KEY == 'a' then CONTROL.L = -1
		elseif KEY == 'd' then CONTROL.R = 1
		elseif QEfly and KEY == 'e' then CONTROL.Q = 1
		elseif QEfly and KEY == 'q' then CONTROL.E = -1
		end
	end)

	if flyKeyUpConnection then flyKeyUpConnection:Disconnect() end
	flyKeyUpConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if not FLYING then return end
		local KEY = input.KeyCode.Name:lower()
		if KEY == 'w' then CONTROL.F = 0
		elseif KEY == 's' then CONTROL.B = 0
		elseif KEY == 'a' then CONTROL.L = 0
		elseif KEY == 'd' then CONTROL.R = 0
		elseif KEY == 'e' then CONTROL.Q = 0
		elseif KEY == 'q' then CONTROL.E = 0
		end
	end)

	print("IY Fly Enabled (Keyboard)")
end

local function mobilefly()
	if FLYING then NOFLY() end
	wait()
	if not Character or not Humanoid or not HumanoidRootPart then print("Cannot start mobile fly: Character components missing."); return end

	FLYING = true
	local T = HumanoidRootPart
	local camera = Workspace.CurrentCamera
	local v3zero = Vector3.new(0, 0, 0)
	local v3inf = Vector3.new(9e9, 9e9, 9e9)

	if flyBG and flyBG.Parent then flyBG:Destroy() end
	if flyBV and flyBV.Parent then flyBV:Destroy() end

	flyBV = Instance.new("BodyVelocity")
	flyBV.Name = "IYMobileFlyBV"
	flyBV.Parent = T
	flyBV.MaxForce = v3inf
	flyBV.Velocity = v3zero

	flyBG = Instance.new("BodyGyro")
	flyBG.Name = "IYMobileFlyBG"
	flyBG.Parent = T
	flyBG.MaxTorque = v3inf
	flyBG.P = 10000
	flyBG.D = 500

	if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end

	flyRenderStepConnection = RunService.RenderStepped:Connect(function()
		if not FLYING or not Character or not Humanoid or not T or not T.Parent or not flyBV or not flyBV.Parent or not flyBG or not flyBG.Parent then
			if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end
			NOFLY()
			return
		end

		Humanoid.PlatformStand = true
		flyBG.CFrame = camera.CFrame

		local direction = Humanoid.MoveDirection
		local currentSpeed = iyflyspeed * 50

		if direction.Magnitude > 0.01 then
			local lookVector = camera.CFrame.LookVector
			local rightVector = camera.CFrame.RightVector
			local moveDir = (lookVector * -direction.Z) + (rightVector * direction.X)
			flyBV.Velocity = moveDir.Unit * currentSpeed
		else
			flyBV.Velocity = v3zero
		end
	end)

	if flyCharacterAddedConnection then flyCharacterAddedConnection:Disconnect(); flyCharacterAddedConnection = nil end
	flyCharacterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
		Character = newChar
		Humanoid = newChar:WaitForChild("Humanoid", 5)
		HumanoidRootPart = newChar:WaitForChild("HumanoidRootPart", 5)
		T = HumanoidRootPart
		if FLYING then
			task.wait(0.5)
			if T and T.Parent then
				if flyBG and flyBG.Parent then flyBG:Destroy() end
				if flyBV and flyBV.Parent then flyBV:Destroy() end
				flyBV = Instance.new("BodyVelocity")
				flyBV.Name = "IYMobileFlyBV"
				flyBV.Parent = T
				flyBV.MaxForce = v3inf
				flyBV.Velocity = v3zero
				flyBG = Instance.new("BodyGyro")
				flyBG.Name = "IYMobileFlyBG"
				flyBG.Parent = T
				flyBG.MaxTorque = v3inf
				flyBG.P = 10000
				flyBG.D = 500
				print("Mobile fly movers re-created on respawn.")
			else
				warn("Failed to re-create mobile fly movers on respawn: RootPart not found.")
				NOFLY()
			end
		end
	end)

	print("IY Fly Enabled (Mobile)")
end

local function unmobilefly()
	FLYING = false
	if flyRenderStepConnection then flyRenderStepConnection:Disconnect(); flyRenderStepConnection = nil end
	if flyCharacterAddedConnection then flyCharacterAddedConnection:Disconnect(); flyCharacterAddedConnection = nil end

	local currentRootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	if currentRootPart then
		local bv = currentRootPart:FindFirstChild("IYMobileFlyBV")
		local bg = currentRootPart:FindFirstChild("IYMobileFlyBG")
		if bv then bv:Destroy() end
		if bg then bg:Destroy() end
	end
	flyBG = nil
	flyBV = nil

	if Humanoid then Humanoid.PlatformStand = false end
	print("IY Mobile Fly Disabled")
end

local function toggleFly()
	FLYING = not FLYING
	print("Fly Toggled:", FLYING and "ON" or "OFF")
	if FLYING then
		if UserInputService.TouchEnabled then
			mobilefly()
		else
			sFLY()
		end
	else
		if UserInputService.TouchEnabled then
			unmobilefly()
		else
			NOFLY()
		end
	end
	-- Rayfield toggle might update automatically, if not, update here:
	-- if flyToggleRef then flyToggleRef:Set(FLYING) end
end

-- Platform Logic
local function createPlatform()
	if platformPartRef and platformPartRef.Parent then
        print("Platform already exists.")
        if platformPartRef.Position ~= TARGET_POSITION_G then
            print("Updating existing platform position.")
            platformPartRef.Position = TARGET_POSITION_G
        end
        return
    end
    if platformPartRef then platformPartRef = nil end

	print("Attempting to create Platform...")
	platformPartRef = Instance.new("Part")
	platformPartRef.Name = "FloatingPlatform_Scripted"
	platformPartRef.Size = PLATFORM_SIZE
	platformPartRef.Position = TARGET_POSITION_G
	platformPartRef.Color = PLATFORM_COLOR
	platformPartRef.Material = Enum.Material.Plastic
	platformPartRef.Anchored = PLATFORM_ANCHORED
    platformPartRef.Transparency = isPlatformVisible and PLATFORM_TRANSPARENCY_VISIBLE or PLATFORM_TRANSPARENCY_HIDDEN
	platformPartRef.CanCollide = isPlatformVisible and PLATFORM_CAN_COLLIDE or false
    platformPartRef.CanTouch = isPlatformVisible
    platformPartRef.CanQuery = isPlatformVisible
	platformPartRef.Parent = Workspace
	print("Platform Created in Workspace at Y:", TARGET_POSITION_G.Y, "Initial State:", isPlatformVisible and "VISIBLE" or "HIDDEN")
end

local function togglePlatform()
    print("Toggle Platform called. Current state (before toggle):", isPlatformVisible)
	isPlatformVisible = not isPlatformVisible
    print("Platform state toggled to:", isPlatformVisible and "VISIBLE" or "HIDDEN")

	if not platformPartRef or not platformPartRef.Parent then
        warn("Platform part reference lost or destroyed. Recreating...")
		createPlatform()
	elseif platformPartRef.Position ~= TARGET_POSITION_G then
        print("Platform exists but position is outdated. Updating position to Y:", TARGET_POSITION_G.Y)
        platformPartRef.Position = TARGET_POSITION_G
    end

	if platformPartRef and platformPartRef.Parent then
        local targetTransparency = isPlatformVisible and PLATFORM_TRANSPARENCY_VISIBLE or PLATFORM_TRANSPARENCY_HIDDEN
        local targetCollide = isPlatformVisible and PLATFORM_CAN_COLLIDE or false
        local targetTouch = isPlatformVisible
        local targetQuery = isPlatformVisible

		platformPartRef.Transparency = targetTransparency
		platformPartRef.CanCollide = targetCollide
        platformPartRef.CanTouch = targetTouch
        platformPartRef.CanQuery = targetQuery
        print("Platform properties updated: Transparency =", targetTransparency, "CanCollide =", targetCollide)
	else
        warn("Failed to find or create platform part to update properties.")
    end
	-- Rayfield toggle might update automatically, if not, update here:
    -- if platformToggleRef then platformToggleRef:Set(isPlatformVisible) end
end

-- Detection Visualizers
local gVisualizerPartRef = nil
local hVisualizerPartRef = nil
local function createDetectionVisualizers()
	if not gVisualizerPartRef or not gVisualizerPartRef.Parent then
        if gVisualizerPartRef then gVisualizerPartRef:Destroy() end
		local sphereG = Instance.new("Part")
		sphereG.Name = "G_DetectionZoneVisualizer"
		sphereG.Shape = Enum.PartType.Ball
		sphereG.Size = Vector3.new(DETECTION_RADIUS_G*2, DETECTION_RADIUS_G*2, DETECTION_RADIUS_G*2)
		sphereG.Position = DETECT_POSITION_G
		sphereG.Color = Color3.fromRGB(0, 255, 255)
		sphereG.Material = Enum.Material.ForceField
		sphereG.Transparency = 0.7
		sphereG.Anchored = true
		sphereG.CanCollide = false
		sphereG.CanTouch = false
		sphereG.CanQuery = false
		sphereG.Visible = isGFuncEnabled
		sphereG.Parent = Workspace
		gVisualizerPartRef = sphereG
		print("G Detection Visualizer Created at Y:", DETECT_POSITION_G.Y)
    elseif gVisualizerPartRef.Position ~= DETECT_POSITION_G then
        print("Updating G Visualizer position to Y:", DETECT_POSITION_G.Y)
        gVisualizerPartRef.Position = DETECT_POSITION_G
	end
	if not hVisualizerPartRef or not hVisualizerPartRef.Parent then
        if hVisualizerPartRef then hVisualizerPartRef:Destroy() end
		local sphereH = Instance.new("Part")
		sphereH.Name = "H_DetectionZoneVisualizer"
		sphereH.Shape = Enum.PartType.Ball
		sphereH.Size = Vector3.new(DETECTION_RADIUS_H*2, DETECTION_RADIUS_H*2, DETECTION_RADIUS_H*2)
		sphereH.Position = TARGET_POSITION_H
		sphereH.Color = Color3.fromRGB(255, 255, 0)
		sphereH.Material = Enum.Material.ForceField
		sphereH.Transparency = 0.7
		sphereH.Anchored = true
		sphereH.CanCollide = false
		sphereH.CanTouch = false
		sphereH.CanQuery = false
		sphereH.Visible = isHFuncEnabled
		sphereH.Parent = Workspace
		hVisualizerPartRef = sphereH
		print("H Detection Visualizer Created.")
	end

	LocalPlayer.CharacterRemoving:Connect(function(removedCharacter)
        print("CharacterRemoving event fired.")
		if gVisualizerPartRef and gVisualizerPartRef.Parent then gVisualizerPartRef:Destroy() end
        gVisualizerPartRef = nil
		if hVisualizerPartRef and hVisualizerPartRef.Parent then hVisualizerPartRef:Destroy() end
        hVisualizerPartRef = nil
		if platformPartRef and platformPartRef.Parent then platformPartRef:Destroy() end
        platformPartRef = nil
        if FLYING then
            if UserInputService.TouchEnabled then unmobilefly() else NOFLY() end
        end
        print("Cleaned up visualizers, platform, and fly state.")
	end)
end

-- Game Loops
RunService.RenderStepped:Connect(function(deltaTime)
	if isAntiFallEnabled then
		local currentTime = tick()
		if currentTime - lastAntiFallTime >= ANTI_FALL_COOLDOWN then
			local player = LocalPlayer
			local character = player.Character
			if character then
				local currentRootPart = character:FindFirstChild("HumanoidRootPart")
				if currentRootPart then
					if currentRootPart.Position.Y < ANTI_FALL_Y_THRESHOLD then
						print("Anti-Fall triggered!")
						teleportPlayerToCoords(TARGET_POSITION_R, "Anti-Fall")
						lastAntiFallTime = currentTime
					end
				end
			end
		end
	end
end)

local function detectNearbyPlayersAndTriggerE_Loop()
	while task.wait(0.1) do
		if isGFuncEnabled and not isPartTeleporting then
			local currentTime = tick()
			if currentTime - lastPlayerDetectTime_G >= PLAYER_DETECT_COOLDOWN_G then
				local localPlayer = LocalPlayer
				local localChar = localPlayer.Character
				if not localChar then continue end

				local foundTarget = false
				for _, player in ipairs(Players:GetPlayers()) do
					if player ~= localPlayer then
						local character = player.Character
						if character then
							local hrp = character:FindFirstChild("HumanoidRootPart")
							if hrp then
								local distance = (hrp.Position - DETECT_POSITION_G).Magnitude
								if distance <= DETECTION_RADIUS_G then
									print("DEBUG: Player '"..player.Name.."' detected near G (Dist: "..string.format("%.2f", distance).."). Triggering E.")
									task.spawn(handlePartTeleport, TARGET_PART_NAME_E, TELEPORT_DURATION_E, "G Detection")
									lastPlayerDetectTime_G = currentTime
									foundTarget = true
									break
								end
                            end
                        end
					end
				end
            end
		end
	end
end

local function detectNearbyPlayersAndTriggerQ_Loop()
	while task.wait(0.1) do
		if isHFuncEnabled and not isPartTeleporting then
			local currentTime = tick()
			if currentTime - lastPlayerDetectTime_H >= PLAYER_DETECT_COOLDOWN_H then
				local localPlayer = LocalPlayer
				local localChar = localPlayer.Character
				if not localChar then continue end

				local foundTarget = false
				for _, player in ipairs(Players:GetPlayers()) do
					if player ~= localPlayer then
						local character = player.Character
						if character then
							local hrp = character:FindFirstChild("HumanoidRootPart")
							if hrp then
								local distance = (hrp.Position - TARGET_POSITION_H).Magnitude
								if distance <= DETECTION_RADIUS_H then
									print("Player '"..player.Name.."' detected near H (Dist: "..string.format("%.2f", distance).."). Triggering Q.")
									task.spawn(handlePartTeleport, TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "H Detection")
									lastPlayerDetectTime_H = currentTime
									foundTarget = true
									break
								end
							end
						end
					end
				end
			end
		end
	end
end

-- Initialization
local uiSuccess, uiError = pcall(function()
    print("Initializing UI and World Objects...")

    -- Create Rayfield UI
    local Window = Rayfield:CreateWindow({
        Name = "Script Controls",
        LoadingTitle = "Loading Script...",
        LoadingSubtitle = "by You",
        ConfigurationSaving = {
            Enabled = false, -- Disable Rayfield's saving if you handle it elsewhere
            FolderName = nil,
            FileName = "ScriptConfig"
        },
        KeySystem = false -- Assuming no key system needed
    })

    local MainTab = Window:CreateTab("Main", 4483362458) -- Example icon ID

    MainTab:CreateButton({
        Name = "TP Parts (Q)",
        Callback = function()
            pcall(handlePartTeleport, TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "UI Button Q")
        end,
    })

    MainTab:CreateButton({
        Name = "TP Troll Part (E)",
        Callback = function()
            pcall(handlePartTeleport, TARGET_PART_NAME_E, TELEPORT_DURATION_E, "UI Button E")
        end,
    })

     MainTab:CreateButton({
        Name = "TP Location (R)",
        Callback = function()
            pcall(teleportPlayerToCoords, TARGET_POSITION_R, "UI Button R")
        end,
    })

    MainTab:CreateLabel("Toggles:")

    antiFallToggleRef = MainTab:CreateToggle({
        Name = "Anti-Fall (F)",
        CurrentValue = isAntiFallEnabled,
        Flag = "AntiFallToggle", -- Optional flag for saving/loading if needed
        Callback = function(Value)
            -- Check if the state actually changed before toggling
            if isAntiFallEnabled ~= Value then
                toggleAntiFall()
            end
        end,
    })

    gFuncToggleRef = MainTab:CreateToggle({
        Name = "Detect E (G)",
        CurrentValue = isGFuncEnabled,
        Flag = "DetectEToggle",
        Callback = function(Value)
             if isGFuncEnabled ~= Value then
                toggleGFunc()
            end
        end,
    })

     hFuncToggleRef = MainTab:CreateToggle({
        Name = "Detect Q (H)",
        CurrentValue = isHFuncEnabled,
        Flag = "DetectQToggle",
        Callback = function(Value)
             if isHFuncEnabled ~= Value then
                toggleHFunc()
            end
        end,
    })

    flyToggleRef = MainTab:CreateToggle({
        Name = "Fly (X)",
        CurrentValue = FLYING,
        Flag = "FlyToggle",
        Callback = function(Value)
             if FLYING ~= Value then
                toggleFly()
            end
        end,
    })

    platformToggleRef = MainTab:CreateToggle({
        Name = "Platform (P)",
        CurrentValue = isPlatformVisible,
        Flag = "PlatformToggle",
        Callback = function(Value)
            if isPlatformVisible ~= Value then
                togglePlatform()
            end
        end,
    })

	createDetectionVisualizers()
    createPlatform()
    print("Initialization complete.")
end)

if not uiSuccess then
	warn("Error during UI/World Initialization:", uiError)
end

-- Start Detection Loops
task.spawn(detectNearbyPlayersAndTriggerE_Loop)
task.spawn(detectNearbyPlayersAndTriggerQ_Loop)
print("Detection loops started.")

-- Connect Input Handling (Keep keybinds active alongside UI)
local inputSuccess, inputError = pcall(function()
    if flyKeyDownConnection then flyKeyDownConnection:Disconnect(); flyKeyDownConnection = nil end
    if flyKeyUpConnection then flyKeyUpConnection:Disconnect(); flyKeyUpConnection = nil end

	UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
		if gameProcessedEvent or (FLYING and input.KeyCode ~= TRIGGER_KEY_FLY) then return end

		local keyCode = input.KeyCode

		if keyCode == TRIGGER_KEY_Q then
            print("Q Key Pressed")
			pcall(handlePartTeleport, TARGET_PART_NAME_Q, TELEPORT_DURATION_Q, "Q Key")
		elseif keyCode == TRIGGER_KEY_E then
            print("E Key Pressed")
			pcall(handlePartTeleport, TARGET_PART_NAME_E, TELEPORT_DURATION_E, "E Key")
		elseif keyCode == TRIGGER_KEY_R then
            print("R Key Pressed")
			pcall(teleportPlayerToCoords, TARGET_POSITION_R, "R Key")
		elseif keyCode == TRIGGER_KEY_F then
            print("F Key Pressed")
			pcall(toggleAntiFall)
            if antiFallToggleRef then antiFallToggleRef:Set(isAntiFallEnabled) end -- Update UI on keypress
		elseif keyCode == TRIGGER_KEY_G then
            print("G Key Pressed")
			pcall(toggleGFunc)
            if gFuncToggleRef then gFuncToggleRef:Set(isGFuncEnabled) end
		elseif keyCode == TRIGGER_KEY_H then
            print("H Key Pressed")
			pcall(toggleHFunc)
            if hFuncToggleRef then hFuncToggleRef:Set(isHFuncEnabled) end
		elseif keyCode == TRIGGER_KEY_FLY then
            print("X Key Pressed")
            pcall(toggleFly)
            if flyToggleRef then flyToggleRef:Set(FLYING) end
        elseif keyCode == TRIGGER_KEY_PLATFORM then
            print("P Key Pressed")
            pcall(togglePlatform)
            if platformToggleRef then platformToggleRef:Set(isPlatformVisible) end
		end
	end)
end)

if not inputSuccess then
	warn("Error connecting Input Handler:", inputError)
else
	print("Teleporting, Anti-Fall, Player Detect, Fly & Platform script input handler loaded. Keys: Q, E, R, F, G, H, X, P.")
end

-- Respawn Handling
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    print("CharacterAdded event fired. Updating references and recreating objects.")
    task.wait(0.2)
    Character = newCharacter
    local success
    success = pcall(function() Humanoid = newCharacter:WaitForChild("Humanoid", 5) end)
    if not success or not Humanoid then warn("Failed to get Humanoid on respawn.") return end
    success = pcall(function() HumanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart", 5) end)
    if not success or not HumanoidRootPart then warn("Failed to get HumanoidRootPart on respawn.") return end

    print("Character references updated.")

    if FLYING then
        print("Re-applying fly state after respawn.")
        task.wait(0.5)
        if UserInputService.TouchEnabled then
            mobilefly()
        else
            sFLY()
        end
    end
    createDetectionVisualizers()
    createPlatform()
    -- No need to recreate UI elements as Rayfield persists
    print("Respawn setup complete.")
end)
